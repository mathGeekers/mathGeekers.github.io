{
  "name": "Mathgeekers.GitHub.io",
  "tagline": "数学极客博客",
  "body": "### 处理JavaScript异步编程嵌套回调问题的利器——js promise\r\n###### By Gauss from MathGeeks\r\n- 传统的async不能很好的应对需求的变化，即当业务逻辑发生变化时，需要大幅度的修改原有的代码结构，promise可以轻松应对需求变化。\r\n\r\n#### 一、什么是promise\r\n- a.一个异步操作的最终结果\r\n- b.交互方式：\r\n```\r\npromise.then(function(value){\r\n//then方法接收回调函数的类型可以是任意的js对象，包括promise对象本身，因此可以实现链式嵌套\r\n返回正确的promise对象\r\n}，function(err){\r\n//返回错误err对象\r\n})\r\n```\r\n类比Java中的一个\r\n```\r\ntry(){\r\n\r\n}catch(Exception e){\r\n\r\n}方法\r\n```\r\n### 二、promise的状态\r\n- a.pending(初始状态)\r\n- b.fulfilled(成功执行)\r\n- c.reject(执行出错)\r\n\r\n    pending状态可以转化到fulfilled和reject两种状态，即成功与失败，而fulfiled和reject两种状态不能转化成其他状态（且必须有一个identity不变的值）\r\n\r\n### 三、then方法\r\n- then方法可以接受两个参数\r\n```    \r\npromise.then(onFulfilled,onReject)\r\n```\r\n    \r\n    1.如果onFulfilled是一个函数，则其第一个参数为promise返回的value值，且其只能在promise进入fulfilled状态后被调用\r\n    2.如果onReject是一个函数，则其第一个参数为promise返回的err reason值，且其只能在promise进入reject之后被调用\r\n\r\n上述两种函数均不能多次调用,如果两个参数不是函数，则必须被忽略\r\n3.then方法可以被多次调用，即\r\n```\r\npromise.then().then().then()\r\n```\r\n------------------------------------------------------\r\n\r\n例：(1)创建promise类\r\n```\r\nfunction runAsync(){ 7\r\n    var p = new Promise(function(resolve, reject){\r\n        //做一些异步操作\r\n        setTimeout(function(){\r\n            console.log('执行完成');\r\n            resolve('随便什么数据');\r\n        }, 2000);\r\n    });\r\n    return p;            \r\n}\r\nrunAsync()\r\n```\r\n(2)调用then方法：\r\n```\r\nrunAsync().then(function(data){\r\n    console.log(data);\r\n    //后面可以用传过来的数据做些其他操作\r\n    //......\r\n});\r\n```\r\n输出结果：\r\n\r\n######  执行完成\r\n\r\n###### 随便什么数据\r\n\r\n(3)then方法的链式调用：\r\n```\r\nrunAsync1()\r\n.then(function(data){\r\n    console.log(data);\r\n    return runAsync2();\r\n})\r\n.then(function(data){\r\n    console.log(data);\r\n    return runAsync3();\r\n})\r\n.then(function(data){\r\n    console.log(data);\r\n});\r\n```\r\n### 四、 catch方法与reject函数\r\n\r\nreject使得promise进入reject状态，可以捕获请求错误的原因\r\n\r\n例：\r\n```\r\nfunction getNumber(){\r\n    var p = new Promise(function(resolve, reject){\r\n        //做一些异步操作\r\n        setTimeout(function(){\r\n            var num = Math.ceil(Math.random()*10); //生成1-10的随机数\r\n            if(num<=5){\r\n                resolve(num);\r\n            }\r\n            else{\r\n                reject('数字太大了');\r\n            }\r\n        }, 2000);\r\n    });\r\n    return p;            \r\n}\r\n```\r\n```\r\ngetNumber()\r\n.then(\r\n    function(data){\r\n        console.log('resolved');\r\n        console.log(data);//两者是一致的；\r\n    }, \r\n    function(reason, data){\r\n        console.log('rejected');\r\n        console.log(reason);\r\nconsole.log(data);//什么结果？\r\n    }\r\n);\r\n```\r\n\r\n返回结果为数字或者'数字太大了'\r\n\r\nCatch方法与reject相似，只不过catch方法可以捕获代码中的异常，防止js运行过程中报错而中止进程\r\n\r\n### 五、all方法与race方法——以函数运行速度决定结果\r\n- 1.all方法\r\n```\r\npromise.all(f1,f2,f3).then()\r\n```\r\n只有当所有的f1,f2,f3都执行完毕后才运行then方法，也就是取决于执行速度最慢的那个函数——在浏览器中一般会加载完所有的资源(图片、文字)才会刷新整个页面 \r\n\r\n2.race方法\r\n```\r\npromise.race(f1,f2,f3).then()\r\n```\r\n只要f1,f2,f3中有一个执行完毕，then方法就会被触发——一般用于资源请求超时处理\r\n\r\n### 六、jQuery中的promise\r\n-  (1)$.Deferred()对象\r\n```\r\nfunction runAsync(){\r\n    var def = $.Deferred();\r\n    //做一些异步操作\r\n    setTimeout(function(){\r\n        console.log('执行完成');\r\n        def.resolve('随便什么数据');\r\n    }, 2000);\r\n    return def;\r\n}\r\nrunAsync().then(function(data){\r\n    console.log(data)\r\n});\r\n```\r\n\r\n相当于将原来定义promise的过程封装了一下，def就相当于上述代码中的p,def无需传入resolve和reject，而是本身就具有这两个方法，可以直接调用。但是这样会有代码被篡改结果的风险，于是加入限制方法def.promise,这样def就不具有resolve和reject方法了\r\n\r\ndeferred同样可以调用then方法及链式法则，并且deffred的then方法得到了增强：\r\n```\r\ndefferd.then(donefilter,failfilter,progressfilter（肯定会执行）)//----接收pending状态的回调函数\r\n```\r\n- done与fail方法\r\n\r\ndone()与then方法成功执行的状态对应，fail()与失败状态对应\r\n\r\n- (2)$.when()对象\r\n相当于promise.all()方法\r\n\r\n区别：\r\n```\r\nPromise\r\n.all([runAsync1(), runAsync2(), runAsync3()])\r\n.then(function(results){\r\n    console.log(results);\r\n});\r\n```\r\n-------------------------------------------------\r\n```\r\n$.when(runAsync(), runAsync2(), runAsync3())\r\n.then(function(data1, data2, data3){\r\n    console.log('全部执行完成');\r\n    console.log(data1, data2, data3);\r\n});//输出与all方法区别\r\n```\r\n(3)ajax与deffered关系\r\n\r\njquery的ajax返回一个受限的Deferred对象，具有deferred对象的所有性质，所以可以采用链式法则，例如：\r\n\r\n```\r\nreq1 = function(){\r\n    return $.ajax(/*...*/);\r\n}\r\nreq2 = function(){\r\n    return $.ajax(/*...*/);\r\n}\r\nreq3 = function(){\r\n    return $.ajax(/*...*/);\r\n}\r\n\r\nreq1().then(req2).then(req3).done(function(){\r\n    console.log('请求发送完毕');\r\n});\r\n```\r\n其实这也就是ajax返回对象的实质\r\n\r\n- (4) success、error与complete\r\n分别对应done、fail、always(持续运行)方法\r\n\r\n例：\r\n```\r\n$.ajax(/*...*/)\r\n.success(function(){/*...*/})\r\n.error(function(){/*...*/})\r\n.complete(function(){/*...*/})\r\n```\r\n### 七、promise的解析过程\r\n探究\r\n\r\n- 参考文献：\r\n\r\n大白话讲解Promise（一）http://www.cnblogs.com/lvdabao/p/es6-promise-1.html\r\n\r\nPromise/A+规范----https://segmentfault.com/a/1190000002452115\r\n\r\n大白话讲解Promise（三）搞懂jquery中的Promise--http://www.cnblogs.com/lvdabao/p/jquery-deferred.html\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}